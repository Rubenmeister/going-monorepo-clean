{"version":3,"file":"main.js","mappings":"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","sources":["external commonjs \"tslib\"","external commonjs \"@nestjs/common\"","external commonjs \"reflect-metadata\"","external commonjs \"@nestjs/core\"","external commonjs \"@nestjs/config\"","external commonjs \"@nestjs/jwt\"","external commonjs \"@prisma/client\"","C:\\Users\\USER1\\going-monorepo-clean\\libs\\shared\\prisma-client\\src\\lib\\prisma.service.ts","C:\\Users\\USER1\\going-monorepo-clean\\libs\\shared\\prisma-client\\src\\lib\\prisma.module.ts","external commonjs \"uuid\"","external commonjs \"neverthrow\"","C:\\Users\\USER1\\going-monorepo-clean\\libs\\domains\\user\\core\\src\\lib\\value-objects\\role.vo.ts","C:\\Users\\USER1\\going-monorepo-clean\\libs\\domains\\user\\core\\src\\lib\\entities\\user.entity.ts","external commonjs \"class-validator\"","C:\\Users\\USER1\\going-monorepo-clean\\libs\\domains\\user\\core\\src\\lib\\dto\\register-user.dto.ts","C:\\Users\\USER1\\going-monorepo-clean\\libs\\domains\\user\\core\\src\\lib\\ports\\iuser.repository.ts","C:\\Users\\USER1\\going-monorepo-clean\\libs\\domains\\user\\core\\src\\lib\\ports\\ipassword.hasher.ts","C:\\Users\\USER1\\going-monorepo-clean\\libs\\domains\\user\\core\\src\\lib\\ports\\itoken.service.ts","C:\\Users\\USER1\\going-monorepo-clean\\user-auth-service\\src\\infrastructure\\repositories\\user.repository.ts","external commonjs \"bcrypt\"","C:\\Users\\USER1\\going-monorepo-clean\\user-auth-service\\src\\infrastructure\\services\\bcrypt.hasher.ts","C:\\Users\\USER1\\going-monorepo-clean\\user-auth-service\\src\\infrastructure\\services\\jwt.token.service.ts","C:\\Users\\USER1\\going-monorepo-clean\\user-auth-service\\src\\infrastructure\\infrastructure.module.ts","C:\\Users\\USER1\\going-monorepo-clean\\libs\\domains\\user\\application\\src\\lib\\dto\\register-user.dto.ts","C:\\Users\\USER1\\going-monorepo-clean\\libs\\domains\\user\\application\\src\\lib\\dto\\login-user.dto.ts","C:\\Users\\USER1\\going-monorepo-clean\\libs\\domains\\user\\application\\src\\lib\\use-cases\\register-user.use-case.ts","C:\\Users\\USER1\\going-monorepo-clean\\libs\\domains\\user\\application\\src\\lib\\use-cases\\login-user.use-case.ts","C:\\Users\\USER1\\going-monorepo-clean\\user-auth-service\\src\\api\\auth.controller.ts","C:\\Users\\USER1\\going-monorepo-clean\\user-auth-service\\src\\app\\app.module.ts","C:\\Users\\USER1\\going-monorepo-clean\\user-auth-service\\src\\main.ts"],"sourcesContent":["const __WEBPACK_NAMESPACE_OBJECT__ = require(\"tslib\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@nestjs/common\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"reflect-metadata\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@nestjs/core\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@nestjs/config\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@nestjs/jwt\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@prisma/client\");","import { Injectable, OnModuleInit, OnModuleDestroy, Logger } from '@nestjs/common';\r\nimport { PrismaClient } from '@prisma/client';\r\n\r\n@Injectable()\r\nexport class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {\r\n  private readonly logger = new Logger(PrismaService.name);\r\n\r\n  constructor() {\r\n    super({\r\n      log: process.env.NODE_ENV === 'development' \r\n        ? ['query', 'info', 'warn', 'error'] \r\n        : ['error'],\r\n    });\r\n  }\r\n\r\n  async onModuleInit() {\r\n    try {\r\n      await this.$connect();\r\n      this.logger.log('Connected to PostgreSQL database');\r\n    } catch (error) {\r\n      this.logger.error('Failed to connect to PostgreSQL database', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async onModuleDestroy() {\r\n    await this.$disconnect();\r\n    this.logger.log('Disconnected from PostgreSQL database');\r\n  }\r\n\r\n  /**\r\n   * Execute operations within a transaction\r\n   * All operations succeed or all fail together\r\n   */\r\n  async executeTransaction<T>(\r\n    fn: (tx: Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>) => Promise<T>,\r\n  ): Promise<T> {\r\n    return this.$transaction(fn);\r\n  }\r\n\r\n  /**\r\n   * Clean database for testing purposes\r\n   * WARNING: This deletes all data!\r\n   */\r\n  async cleanDatabase() {\r\n    if (process.env.NODE_ENV !== 'test') {\r\n      throw new Error('cleanDatabase can only be used in test environment');\r\n    }\r\n    \r\n    const tablenames = await this.$queryRaw<Array<{ tablename: string }>>`\r\n      SELECT tablename FROM pg_tables WHERE schemaname='public'\r\n    `;\r\n\r\n    for (const { tablename } of tablenames) {\r\n      if (tablename !== '_prisma_migrations') {\r\n        await this.$executeRawUnsafe(`TRUNCATE TABLE \"public\".\"${tablename}\" CASCADE;`);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Global, Module } from '@nestjs/common';\r\nimport { PrismaService } from './prisma.service';\r\n\r\n@Global()\r\n@Module({\r\n  providers: [PrismaService],\r\n  exports: [PrismaService],\r\n})\r\nexport class PrismaModule {}\r\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"uuid\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"neverthrow\");","import { Result, ok, err } from 'neverthrow';\r\n// Importamos el RoleType desde la entidad para mantener consistencia\r\nimport { RoleType } from '../entities/user.entity';\r\n\r\nexport class Role {\r\n  private constructor(public readonly value: RoleType) {}\r\n\r\n  public static create(value: string | RoleType): Result<Role, Error> {\r\n    // Validaci√≥n simple: verificamos si el valor est√° en el Enum\r\n    if (!Object.values(RoleType).includes(value as RoleType)) {\r\n      return err(new Error(`Invalid role: ${value}`));\r\n    }\r\n    return ok(new Role(value as RoleType));\r\n  }\r\n\r\n  // M√©todo helper para recuperar desde primitivos (Base de datos)\r\n  public static fromPrimitives(value: string): Role {\r\n    return new Role(value as RoleType);\r\n  }\r\n\r\n  public toPrimitives(): string {\r\n    return this.value;\r\n  }\r\n}","import { v4 as uuidv4 } from 'uuid';\r\nimport { Result, ok, err } from 'neverthrow';\r\n// Si tienes problemas con esta librer√≠a, cambia UUID por string.\r\nimport { UUID } from '@going-monorepo-clean/shared-domain'; \r\nimport { Role } from '../value-objects/role.vo';\r\nimport { IPasswordHasher } from '../ports/ipassword-hasher'; // Aseg√∫rate que este nombre de archivo coincida\r\n\r\nexport type UserStatus = 'pending_verification' | 'active' | 'suspended';\r\n\r\n// ‚úÖ DEFINIMOS Y EXPORTAMOS EL ENUM AQU√ç PARA QUE LOS DTOs LO ENCUENTREN\r\nexport enum RoleType {\r\n  USER = 'USER',\r\n  ADMIN = 'ADMIN',\r\n  DRIVER = 'DRIVER',\r\n  HOST = 'HOST'\r\n}\r\n\r\nexport interface UserProps {\r\n  id: UUID;\r\n  email: string;\r\n  passwordHash: string;\r\n  firstName: string;\r\n  lastName: string;\r\n  phone?: string;\r\n  roles: Role[];\r\n  status: UserStatus;\r\n  createdAt: Date;\r\n  verificationToken?: string;\r\n}\r\n\r\nexport class User {\r\n  readonly id: UUID;\r\n  readonly email: string;\r\n  readonly passwordHash: string;\r\n  readonly firstName: string;\r\n  readonly lastName: string;\r\n  readonly phone?: string;\r\n  readonly roles: Role[];\r\n  readonly status: UserStatus;\r\n  readonly createdAt: Date;\r\n  readonly verificationToken?: string;\r\n\r\n  private constructor(props: UserProps) {\r\n    this.id = props.id;\r\n    this.email = props.email;\r\n    this.passwordHash = props.passwordHash;\r\n    this.firstName = props.firstName;\r\n    this.lastName = props.lastName;\r\n    this.phone = props.phone;\r\n    this.roles = props.roles;\r\n    this.status = props.status;\r\n    this.createdAt = props.createdAt;\r\n    this.verificationToken = props.verificationToken;\r\n  }\r\n\r\n  public static create(props: {\r\n    email: string;\r\n    passwordHash: string;\r\n    firstName: string;\r\n    lastName: string;\r\n    phone?: string;\r\n    roles: Role[];\r\n  }): Result<User, Error> {\r\n    \r\n    if (props.firstName.length < 2) {\r\n      return err(new Error('First name is too short'));\r\n    }\r\n\r\n    const user = new User({\r\n      id: uuidv4(),\r\n      ...props,\r\n      status: 'pending_verification',\r\n      createdAt: new Date(),\r\n      verificationToken: uuidv4(),\r\n    });\r\n\r\n    return ok(user);\r\n  }\r\n\r\n  public toPrimitives(): any {\r\n    return {\r\n      id: this.id,\r\n      email: this.email,\r\n      passwordHash: this.passwordHash,\r\n      firstName: this.firstName,\r\n      lastName: this.lastName,\r\n      phone: this.phone,\r\n      // Asumimos que Role tiene un m√©todo toPrimitives o usamos .value\r\n      roles: this.roles.map(role => role.value), \r\n      status: this.status,\r\n      createdAt: this.createdAt,\r\n      verificationToken: this.verificationToken,\r\n    };\r\n  }\r\n\r\n  public static fromPrimitives(props: any): User {\r\n    return new User({\r\n      ...props,\r\n      // Asumimos que Role.create devuelve un Result o una instancia\r\n      roles: props.roles.map((role: string) => Role.create(role as RoleType)._unsafeUnwrap ? Role.create(role as RoleType)._unsafeUnwrap() : Role.create(role as RoleType)),\r\n    });\r\n  }\r\n\r\n  public verifyAccount(): Result<void, Error> {\r\n    if (this.status === 'active') {\r\n      return err(new Error('Account is already active'));\r\n    }\r\n    (this as any).status = 'active';\r\n    (this as any).verificationToken = undefined;\r\n    return ok(undefined);\r\n  }\r\n\r\n  public checkPassword(password: string, hasher: IPasswordHasher): Promise<boolean> {\r\n    return hasher.compare(password, this.passwordHash);\r\n  }\r\n  \r\n  public hasRole(role: RoleType): boolean {\r\n    return this.roles.some(r => r.value === role);\r\n  }\r\n}","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"class-validator\");","import { IsNotEmpty, IsString, IsEmail, MinLength, IsOptional, IsEnum } from 'class-validator';\r\n//‚úÖ BIEN (Ajusta la ruta seg√∫n donde tengas definido RoleType)\r\nimport { RoleType } from '../entities/user.entity'; \r\n// O si est√° en types: import { RoleType } from '../types/role.type';/ Reemplaza 'going-monorepo-clean' con el scope de tu monorepo\r\n\r\nexport class RegisterUserDto {\r\n  @IsNotEmpty()\r\n  @IsEmail()\r\n  email: string;\r\n\r\n  @IsNotEmpty()\r\n  @IsString()\r\n  @MinLength(8, { message: 'Password must be at least 8 characters' })\r\n  password: string;\r\n\r\n  @IsNotEmpty()\r\n  @IsString()\r\n  firstName: string;\r\n\r\n  @IsNotEmpty()\r\n  @IsString()\r\n  lastName: string;\r\n\r\n  @IsString()\r\n  @IsOptional()\r\n  phone?: string;\r\n\r\n  @IsNotEmpty()\r\n  @IsEnum(RoleType, { each: true })\r\n  roles: RoleType[];\r\n}","import { Result } from 'neverthrow';\r\nimport { User } from '../entities/user.entity';\r\nimport { UUID } from '@going-monorepo-clean/shared-domain'; // Reemplaza con tu scope\r\n\r\nexport const IUserRepository = Symbol('IUserRepository');\r\n\r\nexport interface IUserRepository {\r\n  save(user: User): Promise<Result<void, Error>>;\r\n  update(user: User): Promise<Result<void, Error>>;\r\n  findById(id: UUID): Promise<Result<User | null, Error>>;\r\n  findByEmail(email: string): Promise<Result<User | null, Error>>;\r\n  findByVerificationToken(token: string): Promise<Result<User | null, Error>>;\r\n}","export const IPasswordHasher = Symbol('IPasswordHasher');\r\n\r\nexport interface IPasswordHasher {\r\n  hash(password: string): Promise<string>;\r\n  compare(password: string, hash: string): Promise<boolean>;\r\n}","import { UUID } from '@going-monorepo-clean/shared-domain'; // Reemplaza con tu scope\r\n\r\nexport const ITokenService = Symbol('ITokenService');\r\n\r\nexport interface ITokenService {\r\n  sign(payload: any): string;\r\n  verify(token: string): any;\r\n}","import { Injectable } from '@nestjs/common';\r\nimport { IUserRepository, User } from '@going-monorepo-clean/domains-user-core';\r\nimport { PrismaService } from '@going-monorepo-clean/prisma-client';\r\nimport { Result, ok, err } from 'neverthrow';\r\n\r\n@Injectable()\r\nexport class PrismaUserRepository implements IUserRepository {\r\n  constructor(private readonly prisma: PrismaService) {}\r\n\r\n  async save(user: User): Promise<Result<void, Error>> {\r\n    try {\r\n      const primitives = user.toPrimitives();\r\n      \r\n      await this.prisma.user.create({\r\n        data: {\r\n          id: primitives.id,\r\n          email: primitives.email,\r\n          passwordHash: primitives.passwordHash,\r\n          name: primitives.name,\r\n          role: primitives.role,\r\n          isActive: primitives.isActive ?? true,\r\n        },\r\n      });\r\n\r\n      return ok(undefined);\r\n    } catch (error) {\r\n      return err(new Error(`Failed to save user: ${error.message}`));\r\n    }\r\n  }\r\n\r\n  async update(user: User): Promise<Result<void, Error>> {\r\n    try {\r\n      const primitives = user.toPrimitives();\r\n      \r\n      await this.prisma.user.update({\r\n        where: { id: primitives.id },\r\n        data: {\r\n          email: primitives.email,\r\n          passwordHash: primitives.passwordHash,\r\n          name: primitives.name,\r\n          role: primitives.role,\r\n          isActive: primitives.isActive,\r\n          updatedAt: new Date(),\r\n        },\r\n      });\r\n\r\n      return ok(undefined);\r\n    } catch (error) {\r\n      return err(new Error(`Failed to update user: ${error.message}`));\r\n    }\r\n  }\r\n\r\n  async findById(id: string): Promise<Result<User | null, Error>> {\r\n    try {\r\n      const prismaUser = await this.prisma.user.findUnique({ where: { id } });\r\n      \r\n      if (!prismaUser) {\r\n        return ok(null);\r\n      }\r\n\r\n      return ok(this.toDomain(prismaUser));\r\n    } catch (error) {\r\n      return err(new Error(`Failed to find user by id: ${error.message}`));\r\n    }\r\n  }\r\n\r\n  async findByEmail(email: string): Promise<Result<User | null, Error>> {\r\n    try {\r\n      const prismaUser = await this.prisma.user.findUnique({ where: { email } });\r\n      \r\n      if (!prismaUser) {\r\n        return ok(null);\r\n      }\r\n\r\n      return ok(this.toDomain(prismaUser));\r\n    } catch (error) {\r\n      return err(new Error(`Failed to find user by email: ${error.message}`));\r\n    }\r\n  }\r\n\r\n  async findByVerificationToken(token: string): Promise<Result<User | null, Error>> {\r\n    try {\r\n      // Note: verificationToken field would need to be added to Prisma schema\r\n      // For now, return null as verification tokens are not yet implemented\r\n      return ok(null);\r\n    } catch (error) {\r\n      return err(new Error(`Failed to find user by verification token: ${error.message}`));\r\n    }\r\n  }\r\n\r\n  private toDomain(prismaUser: any): User {\r\n    return User.fromPrimitives({\r\n      id: prismaUser.id,\r\n      email: prismaUser.email,\r\n      passwordHash: prismaUser.passwordHash,\r\n      name: prismaUser.name,\r\n      role: prismaUser.role,\r\n      isActive: prismaUser.isActive,\r\n      createdAt: prismaUser.createdAt,\r\n      updatedAt: prismaUser.updatedAt,\r\n    });\r\n  }\r\n}","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"bcrypt\");","import { Injectable } from '@nestjs/common';\r\nimport * as bcrypt from 'bcrypt';\r\nimport { IPasswordHasher } from '@going-monorepo-clean/domains-user-core'; // Reemplaza con tu scope\r\n\r\n@Injectable()\r\nexport class BcryptHasher implements IPasswordHasher {\r\n  private readonly SALT_ROUNDS = 10;\r\n\r\n  hash(password: string): Promise<string> {\r\n    return bcrypt.hash(password, this.SALT_ROUNDS);\r\n  }\r\n\r\n  compare(password: string, hash: string): Promise<boolean> {\r\n    return bcrypt.compare(password, hash);\r\n  }\r\n}","import { Injectable } from '@nestjs/common';\r\nimport { JwtService } from '@nestjs/jwt';\r\nimport { ITokenService } from '@going-monorepo-clean/domains-user-core'; // Aseg√∫rate de que el scope sea correcto\r\n\r\n@Injectable()\r\nexport class JwtTokenService implements ITokenService {\r\n  constructor(private readonly jwtService: JwtService) {}\r\n\r\n  // 1. Implementaci√≥n del m√©todo 'sign' (Requerido por ITokenService)\r\n  sign(payload: any): string {\r\n    return this.jwtService.sign(payload);\r\n  }\r\n\r\n  // 2. Implementaci√≥n del m√©todo 'verify' (Requerido por ITokenService)\r\n  verify(token: string): any {\r\n    return this.jwtService.verify(token);\r\n  }\r\n\r\n  // (Opcional) Si ten√≠as l√≥gica extra en generateAuthToken, puedes adaptarla aqu√≠,\r\n  // pero el m√©todo 'sign' suele ser suficiente para payloads est√°ndar.\r\n}","import { Module, Global } from '@nestjs/common';\r\nimport { JwtModule } from '@nestjs/jwt';\r\nimport { ConfigModule, ConfigService } from '@nestjs/config';\r\n\r\n// Shared Prisma Module\r\nimport { PrismaModule } from '@going-monorepo-clean/prisma-client';\r\n\r\n// Domain Ports (symbols and interfaces from user-core)\r\nimport { \r\n  IUserRepository,\r\n  IPasswordHasher,\r\n  ITokenService,\r\n} from '@going-monorepo-clean/domains-user-core';\r\n\r\n// Infrastructure Implementations\r\nimport { PrismaUserRepository } from './repositories/user.repository';\r\nimport { BcryptHasher } from './services/bcrypt.hasher';\r\nimport { JwtTokenService } from './services/jwt.token.service';\r\n\r\n@Global()\r\n@Module({\r\n  imports: [\r\n    PrismaModule,\r\n    JwtModule.registerAsync({\r\n      imports: [ConfigModule],\r\n      inject: [ConfigService],\r\n      useFactory: (configService: ConfigService) => ({\r\n        secret: configService.get('JWT_SECRET') || 'default-secret-change-in-production',\r\n        signOptions: { expiresIn: configService.get('JWT_EXPIRATION') || '1h' },\r\n      }),\r\n    }),\r\n  ],\r\n  providers: [\r\n    { provide: IUserRepository, useClass: PrismaUserRepository },\r\n    { provide: IPasswordHasher, useClass: BcryptHasher },\r\n    { provide: ITokenService, useClass: JwtTokenService },\r\n  ],\r\n  exports: [\r\n    IUserRepository,\r\n    IPasswordHasher,\r\n    ITokenService,\r\n    JwtModule,\r\n  ],\r\n})\r\nexport class InfrastructureModule {}","import { IsNotEmpty, IsString, IsEmail, MinLength, IsOptional, IsEnum } from 'class-validator';\r\nimport { RoleType } from '@going-monorepo-clean/domains-user-core'; // Reemplaza con tu scope\r\n\r\nexport class RegisterUserDto {\r\n  @IsNotEmpty()\r\n  @IsEmail()\r\n  email: string;\r\n\r\n  @IsNotEmpty()\r\n  @IsString()\r\n  @MinLength(8, { message: 'Password must be at least 8 characters' })\r\n  password: string;\r\n\r\n  @IsNotEmpty()\r\n  @IsString()\r\n  firstName: string;\r\n\r\n  @IsNotEmpty()\r\n  @IsString()\r\n  lastName: string;\r\n\r\n  @IsString()\r\n  @IsOptional()\r\n  phone?: string;\r\n\r\n  @IsNotEmpty()\r\n  @IsEnum(RoleType, { each: true })\r\n  roles: RoleType[];\r\n}","import { IsNotEmpty, IsString, IsEmail } from 'class-validator';\r\n\r\nexport class LoginUserDto {\r\n  @IsNotEmpty()\r\n  @IsEmail()\r\n  email: string;\r\n\r\n  @IsNotEmpty()\r\n  @IsString()\r\n  password: string;\r\n}","import { Injectable, Inject } from '@nestjs/common';\r\nimport { Result, ok, err } from 'neverthrow';\r\nimport {\r\n  User,\r\n  IUserRepository,\r\n  IPasswordHasher,\r\n  RegisterUserDto,\r\n  RoleType\r\n} from '@going-monorepo-clean/domains-user-core';\r\n// Importamos la implementaci√≥n concreta del Value Object para crearlo\r\n// Aseg√∫rate de que la ruta sea correcta hacia tu Role VO en el Core\r\n// Si Role no se exporta desde el index del core, ajusta esta l√≠nea:\r\nimport { Role } from '../../../../core/src/lib/value-objects/role.vo'; \r\n\r\n@Injectable()\r\nexport class RegisterUserUseCase {\r\n  constructor(\r\n    @Inject(IUserRepository) private readonly userRepository: IUserRepository,\r\n    @Inject(IPasswordHasher) private readonly passwordHasher: IPasswordHasher\r\n  ) {}\r\n\r\n  async execute(dto: RegisterUserDto): Promise<Result<User, Error>> {\r\n    // 1. Verificar si el usuario ya existe\r\n    const existingUser = await this.userRepository.findByEmail(dto.email);\r\n    if (existingUser) {\r\n      return err(new Error('User already exists'));\r\n    }\r\n\r\n    // 2. Hashear contrase√±a\r\n    const passwordHash = await this.passwordHasher.hash(dto.password);\r\n\r\n    // 3. Crear los Roles (Value Objects)\r\n    // Asumimos que el DTO trae un string o un enum, lo convertimos a VO\r\n    const roleResult = Role.create(RoleType.USER); // Por defecto asignamos USER\r\n    if (roleResult.isErr()) {\r\n        return err(roleResult.error);\r\n    }\r\n\r\n    // 4. Crear entidad User\r\n    const userResult = User.create({\r\n      email: dto.email,\r\n      passwordHash: passwordHash,\r\n      firstName: dto.firstName,\r\n      lastName: dto.lastName,\r\n      phone: dto.phone,\r\n      roles: [roleResult.value], \r\n    });\r\n\r\n    if (userResult.isErr()) {\r\n      return err(userResult.error);\r\n    }\r\n\r\n    const user = userResult.value;\r\n\r\n    // 5. Guardar en repositorio\r\n    const saveResult = await this.userRepository.save(user);\r\n    \r\n    if (saveResult.isErr()) {\r\n      return err(saveResult.error);\r\n    }\r\n\r\n    return ok(user);\r\n  }\r\n}","import { Result, ok, err } from 'neverthrow';\r\nimport {\r\n  IUserRepository,\r\n  IPasswordHasher,\r\n  ITokenService,\r\n  User\r\n} from '@going-monorepo-clean/domains-user-core';\r\nimport { LoginUserDto } from '../dto/login-user.dto';\r\n\r\nexport class LoginUserUseCase {\r\n  constructor(\r\n    private readonly userRepository: IUserRepository,\r\n    private readonly passwordHasher: IPasswordHasher,\r\n    private readonly tokenService: ITokenService\r\n  ) {}\r\n\r\n  async execute(dto: LoginUserDto): Promise<Result<{ user: User; token: string }, Error>> {\r\n    // 1. Obtenemos el RESULTADO (la caja)\r\n    const userResult = await this.userRepository.findByEmail(dto.email);\r\n\r\n    // 2. Verificamos si hubo error (Caja vac√≠a / Error)\r\n    if (userResult.isErr()) {\r\n       return err(new Error('Invalid credentials'));\r\n    }\r\n\r\n    // 3. ¬°DESEMPAQUETAMOS! Sacamos el usuario real de la caja\r\n    const user = userResult.value;\r\n\r\n    // 4. Ahora s√≠ podemos acceder a las propiedades del usuario\r\n    const isPasswordValid = await this.passwordHasher.compare(\r\n      dto.password,\r\n      user.passwordHash\r\n    );\r\n\r\n    if (!isPasswordValid) {\r\n      return err(new Error('Invalid credentials'));\r\n    }\r\n\r\n    // 5. Generar Token\r\n    const payload = {\r\n      sub: user.id,\r\n      email: user.email,\r\n      role: typeof user.roles[0] === 'string' ? user.roles[0] : user.roles[0].value \r\n    };\r\n\r\n    const token = this.tokenService.sign(payload);\r\n\r\n    return ok({ user, token });\r\n  }\r\n}","import { Body, Controller, Post, HttpCode, HttpStatus, HttpException } from '@nestjs/common';\r\nimport { \r\n  RegisterUserUseCase, \r\n  LoginUserUseCase,\r\n  RegisterUserDto, \r\n  LoginUserDto, \r\n} from '@going-monorepo-clean/domains-user-application'; \r\n\r\n@Controller('auth')\r\nexport class AuthController {\r\n  \r\n  constructor(\r\n    private readonly registerUserUseCase: RegisterUserUseCase,\r\n    private readonly loginUserUseCase: LoginUserUseCase,\r\n  ) {}\r\n\r\n  @Post('register')\r\n  @HttpCode(HttpStatus.CREATED)\r\n  async register(@Body() registerDto: RegisterUserDto) {\r\n    const result = await this.registerUserUseCase.execute(registerDto);\r\n\r\n    if (result.isErr()) {\r\n      throw new HttpException(result.error.message, HttpStatus.BAD_REQUEST);\r\n    }\r\n    \r\n    return result.value;\r\n  }\r\n\r\n  @Post('login')\r\n  @HttpCode(HttpStatus.OK)\r\n  async login(@Body() loginDto: LoginUserDto) {\r\n    const result = await this.loginUserUseCase.execute(loginDto);\r\n    \r\n    if (result.isErr()) {\r\n      throw new HttpException(result.error.message, HttpStatus.UNAUTHORIZED);\r\n    }\r\n    \r\n    return result.value;\r\n  }\r\n}","import { Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\n\n// Infrastructure module with Prisma\nimport { InfrastructureModule } from '../infrastructure/infrastructure.module';\n\n// API Controllers\nimport { AuthController } from '../api/auth.controller';\n\n// Application layer - Use Cases\nimport {\n  RegisterUserUseCase,\n  LoginUserUseCase,\n} from '@going-monorepo-clean/domains-user-application';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ \n      isGlobal: true,\n      envFilePath: '.env'\n    }),\n    InfrastructureModule,\n  ],\n  controllers: [\n    AuthController,\n  ],\n  providers: [\n    RegisterUserUseCase,\n    LoginUserUseCase,\n  ],\n})\nexport class AppModule {}","import 'reflect-metadata';\nimport { Logger, ValidationPipe } from '@nestjs/common';\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app/app.module';\n\nasync function bootstrap() {\n  const logger = new Logger('Bootstrap');\n  try {\n    const app = await NestFactory.create(AppModule);\n    \n    // üëá ESTO ES VITAL PARA QUE NO DE ERROR \"FAILED TO FETCH\"\n    app.enableCors(); \n    app.setGlobalPrefix('api'); // Esto hace que la ruta sea /api/auth/login\n    \n    app.useGlobalPipes(new ValidationPipe({\n      whitelist: true,\n      transform: true,\n    }));\n\n    const port = process.env.PORT || 3333;\n    await app.listen(port);\n    \n    logger.log(`üöÄ BACKEND LISTO en: http://localhost:${port}/api`);\n  } catch (error) {\n    logger.error('‚ùå ERROR FATAL:', error);\n    process.exit(1);\n  }\n}\nbootstrap();"],"names":["require","PrismaService","PrismaClient","constructor","super","log","process","env","NODE_ENV","logger","Logger","name","onModuleInit","this","$connect","error","onModuleDestroy","$disconnect","executeTransaction","fn","$transaction","cleanDatabase","Error","tablenames","$queryRaw","tablename","$executeRawUnsafe","Injectable","PrismaModule","Global","Module","providers","exports","Role","value","create","Object","values","RoleType","includes","ok","err","fromPrimitives","toPrimitives","User","props","id","email","passwordHash","firstName","lastName","phone","roles","status","createdAt","verificationToken","length","user","Date","map","role","_unsafeUnwrap","verifyAccount","undefined","checkPassword","password","hasher","compare","hasRole","some","r","RegisterUserDto","IsNotEmpty","IsEmail","IsString","MinLength","message","IsOptional","IsEnum","each","IUserRepository","Symbol","IPasswordHasher","ITokenService","PrismaUserRepository","prisma","save","primitives","data","isActive","update","where","updatedAt","findById","prismaUser","findUnique","toDomain","findByEmail","findByVerificationToken","token","BcryptHasher","SALT_ROUNDS","hash","JwtTokenService","jwtService","sign","payload","verify","JwtService","InfrastructureModule","imports","JwtModule","registerAsync","ConfigModule","inject","ConfigService","useFactory","configService","secret","get","signOptions","expiresIn","provide","useClass","LoginUserDto","RegisterUserUseCase","userRepository","passwordHasher","execute","dto","roleResult","USER","isErr","userResult","saveResult","Inject","LoginUserUseCase","tokenService","sub","AuthController","registerUserUseCase","loginUserUseCase","register","registerDto","result","HttpException","HttpStatus","BAD_REQUEST","login","loginDto","UNAUTHORIZED","Post","HttpCode","CREATED","Body","OK","Controller","AppModule","forRoot","isGlobal","envFilePath","controllers","app","NestFactory","enableCors","setGlobalPrefix","useGlobalPipes","ValidationPipe","whitelist","transform","port","PORT","listen","exit","bootstrap"],"ignoreList":[],"sourceRoot":""}