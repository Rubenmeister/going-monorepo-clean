(()=>{"use strict";const e=require("tslib"),t=require("@nestjs/core"),i=require("@nestjs/common"),o=require("@nestjs/config"),r=require("@prisma/client");var a;let s=a=class PrismaService extends r.PrismaClient{constructor(){super({log:"development"===process.env.NODE_ENV?["query","info","warn","error"]:["error"]}),this.logger=new i.Logger(a.name)}onModuleInit(){return(0,e.__awaiter)(this,void 0,void 0,function*(){try{yield this.$connect(),this.logger.log("Connected to PostgreSQL database")}catch(e){throw this.logger.error("Failed to connect to PostgreSQL database",e),e}})}onModuleDestroy(){return(0,e.__awaiter)(this,void 0,void 0,function*(){yield this.$disconnect(),this.logger.log("Disconnected from PostgreSQL database")})}executeTransaction(t){return(0,e.__awaiter)(this,void 0,void 0,function*(){return this.$transaction(t)})}cleanDatabase(){return(0,e.__awaiter)(this,void 0,void 0,function*(){if("test"!==process.env.NODE_ENV)throw new Error("cleanDatabase can only be used in test environment");const e=yield this.$queryRaw`
      SELECT tablename FROM pg_tables WHERE schemaname='public'
    `;for(const{tablename:t}of e)"_prisma_migrations"!==t&&(yield this.$executeRawUnsafe(`TRUNCATE TABLE "public"."${t}" CASCADE;`))})}};s=a=(0,e.__decorate)([(0,i.Injectable)(),(0,e.__metadata)("design:paramtypes",[])],s);let n=class PrismaModule{};var c;n=(0,e.__decorate)([(0,i.Global)(),(0,i.Module)({providers:[s],exports:[s]})],n);let d=class PrismaNotificationRepository{constructor(e){this.prisma=e}createNotification(t){return(0,e.__awaiter)(this,void 0,void 0,function*(){return this.prisma.notification.create({data:Object.assign(Object.assign({},t),{isRead:!1})})})}findNotificationsByUser(t){return(0,e.__awaiter)(this,void 0,void 0,function*(){return this.prisma.notification.findMany({where:{userId:t},orderBy:{createdAt:"desc"}})})}markAsRead(t){return(0,e.__awaiter)(this,void 0,void 0,function*(){return this.prisma.notification.update({where:{id:t},data:{isRead:!0}})})}markAllAsRead(t){return(0,e.__awaiter)(this,void 0,void 0,function*(){return this.prisma.notification.updateMany({where:{userId:t,isRead:!1},data:{isRead:!0}})})}getUnreadCount(t){return(0,e.__awaiter)(this,void 0,void 0,function*(){return this.prisma.notification.count({where:{userId:t,isRead:!1}})})}};d=(0,e.__decorate)([(0,i.Injectable)(),(0,e.__metadata)("design:paramtypes",["function"==typeof(c=void 0!==s&&s)?c:Object])],d);const l=Symbol("INotificationRepository");let u=class InfrastructureModule{};u=(0,e.__decorate)([(0,i.Global)(),(0,i.Module)({imports:[o.ConfigModule.forRoot({isGlobal:!0}),n],providers:[d,{provide:l,useClass:d}],exports:[l,d,s]})],u);let p=class AppModule{};p=(0,e.__decorate)([(0,i.Module)({imports:[o.ConfigModule.forRoot({isGlobal:!0}),u],controllers:[],providers:[]})],p),function(){(0,e.__awaiter)(this,void 0,void 0,function*(){const e=yield t.NestFactory.create(p),o=process.env.PORT||3007;e.useGlobalPipes(new i.ValidationPipe({whitelist:!0,transform:!0})),yield e.listen(o),i.Logger.log(`\ud83d\ude80 Notifications-Service est\xe1 corriendo en http://localhost:${o}`,"Bootstrap")})}()})();
//# sourceMappingURL=main.js.map